- Relies on injecting malicious script to run on a user's browser. Exploits the user's trust in the vulnerable web application.
- Consequently, they bypass the Same-Origin Policy; security mechanism implemented in modern web browsers to prevent a malicious script on one web page from obtaining access to sensitive data on another page. It defines origin based on the protocol, hostname, and port
- Knowing that XSS is a **Client-side attack**, try the attacks on a browser similar to that of the target.
- ### Reasons
	- #### Insufficient input validation and sanitization
		- Accept user data, and use it in the dynamic generation of HTML pages without making sure its clean.
	- #### Lack of output encoding
		- For HTML, encoding characters such as `< > " ' &`.
		- For JavaScript, escaping characters such as `' " \`.
	- #### Improper use of security headers
		- Various security headers can help mitigate XSS vulnerabilities. For example, Content Security Policy (CSP) mitigates XSS risks by defining which sources are trusted for executable scripts.
		- A misconfigured CSP, such as overly permissive policies or the improper use of `unsafe-inline` or `unsafe-eval` directives, makes it easier for the attacker to inject XSS payloads.
	- #### Framework and language vulnerabilities
		- Old frameworks that don't provide security mechanisms against XSS, or unpatched XSS vulnerabilities.
	- #### Third-party libraries
		- Integrating third-party libraries in a web application can introduce XSS vulnerabilities, even if the core web application is not vulnerable.
- ### Implications
	- #### Session hijacking
		- XSS can be used to steal session cookies, which would allow the attacker to impersonate the victim.
	- #### Phishing and credential theft
		- Using XSS, attackers can present a fake login page.
	- #### Content manipulation and defacement
		- Using XSS to change the website for purposes such as inflicting damage on the company's reputation.
	- #### Data exfiltration
		- XSS can access and exfiltrate any information displayed on the user's browser, which could include sensitive data such as personal or financial information.
	- #### Malware installation
		- XSS can be used to spread malware. Deliver drive-by download attacks on the vulnerable website.
- ### Types
	- #### Reflected XSS
		- Relies on the user-controlled input reflected to the user.
		- For example, if user searches for a term and the resulting page is displays the term the user searched for (reflected), the attacker would try to embed a malicious script within the search term.
		- ##### Remediation
			- Sanitize user input, or HTML encode it.
			- `<script>alert('xss')</script>` should be HTML encoded to `&lt;script&gt;alert('xss')&lt;/script&gt;`.
			- **PHP**
				- Use `htmlspecialchars()` function that converts special characters into HTML entities.
			- **JavaScript (Node.js)**
				- Using the `sanitizeHtml()` function from the `sanitize-html` library which removes unsafe elements and attributes.
				- Using `escapeHtml()` function which escapes the characters.
			- **Python (Flask)**
				- Use `escape()` function from the `html` module to escape unsafe characters.
			- **ASP.NET**
				- Use the `HttpUtility.HtmlEncode()` method which converts unsafe characters.
	- #### Stored XSS
		- Relies on the user input stored in the website's database.
		- For example, if user can write product reviews that are saved in a database (stored) and being displayed to other users, the attacker would try to insert malicious script into their review so that it gets executed in the browsers of other users.
		- ##### Remediation
			- **Validate and sanitize input**
				- Define clear rules and enforce strict validation on all user input. For example, only alphanumeric characters can be used for usernames, and only integers can be allowed in age fields.
			- **Use output escaping**
				- When displaying user-supplied data within an HTML, encode all HTML specific characters.
			- **Apply context-specific encoding**
				- For example, within a JavaScript context, we must use JavaScript encoding whenever we insert data within a JavaScript code.
				- For URL, URL encoding is used.
			- **Practice defense in depth**
				- Use multi-layered defense; use server-side validation instead of solely relying on client-side validation.
			- **PHP, JavaScript, Python, and ASP.NET**
				- Same as reflected XSS.
		- Blind XSS is similar to a stored XSS in that our payload gets stored on the website for another user to view, but in this instance, we can't see the payload working or be able to test it against ourselves first.
		- [XSS Hunter Express](https://github.com/mandatoryprogrammer/xsshunter-express) a popular tool for Blind XSS attacks.
	- #### DOM-based XSS
		- Relies on the vulnerabilities within the Document Object Model (DOM) to manipulate existing page elements without needing to be reflected or stored on the server.
		- Least common type.
		- They don't need to go to the server and return to the client's web browser. In other words,  the attacker will try to exploit this situation by injecting a malicious script, for example, into the URL, and it will be executed on the client's side without any role for the server in this.
		- ##### Remediation
			- Use `encodeURIComponent()` function to escape user input.
- ### Context
	- The injected payload will most likely find its way in:
		- Between HTML tags
		- Within HTML tags
		- Inside JavaScript
	- When XSS happens between HTML tags, the attacker can run `<script>alert("xss")</script>`.
	- When XSS happens within an HTML tag, the attacker needs to end the tag to load the script, for example `><script>alert(document.cookie)</script>` or `"><script>alert(document.cookie)</script>`.
	- When XSS happens inside JavaScript, terminate the script first to run the injected one, for example, start with `</script>` to end the script and continue from there.
	- If its within a JavaScript string, close the string with `'`, complete the command with `;`, execute the payload, then comment out the rest of the line using `//`. For example, `';alert(document.cookie)//`.
- ### Evasion
	- Many repositories can be used to create custom XSS payload like [this one](https://github.com/payloadbox/xss-payload-list).
	- Sometimes there are filters blocking XSS payloads, if there is limitation based on payload length, then [Tiny XSS Payloads](https://github.com/terjanq/Tiny-XSS-Payloads) can bypass these restrictions.
	- If XSS payloads are blocked based on specific blocklists, using tricks like a horizontal tab (TAB is `9` in hexadecimal), a new line (LF is `A` in hexadecimal), or a carriage return (CR is `D` in hexadecimal) can break up the payload and evade the detection engine.
	- [Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
	- Break up the payload `<img src="javascript:alert('xss');">` in various ways:
		- `<img src="jav&#x09;ascript:alert('xss');">`
		- `<img src="jav&#x0A;ascript:alert('xss');">`
		- `<img src="jav&#x0D;ascript:alert('xss');">`
